"use strict";(globalThis.webpackChunkui_bridge_docs=globalThis.webpackChunkui_bridge_docs||[]).push([[252],{8453(e,n,r){r.d(n,{R:()=>s,x:()=>o});var t=r(6540);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},9940(e,n,r){r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"guides/tauri","title":"Tauri Desktop Guide","description":"Complete guide for integrating UI Bridge with Tauri desktop applications, including auto-registration and render logging with file-based storage.","source":"@site/docs/guides/tauri.md","sourceDirName":"guides","slug":"/guides/tauri","permalink":"/ui-bridge/docs/guides/tauri","draft":false,"unlisted":false,"editUrl":"https://github.com/qontinui/ui-bridge/tree/main/docs-site/docs/guides/tauri.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Web / Next.js Guide","permalink":"/ui-bridge/docs/guides/web"},"next":{"title":"React Native / Expo Guide","permalink":"/ui-bridge/docs/guides/mobile"}}');var i=r(4848),a=r(8453);const s={sidebar_position:2},o="Tauri Desktop Guide",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Installation",id:"installation",level:2},{value:"Basic Setup",id:"basic-setup",level:2},{value:"1. Add the Provider",id:"1-add-the-provider",level:3},{value:"2. Add Render Logging with Tauri Storage",id:"2-add-render-logging-with-tauri-storage",level:3},{value:"3. Create the Render Log Manager Hook",id:"3-create-the-render-log-manager-hook",level:3},{value:"4. Create the Render Log Wrapper",id:"4-create-the-render-log-wrapper",level:3},{value:"5. Add Rust Commands (Backend)",id:"5-add-rust-commands-backend",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"IPC-Based UI Bridge (Alternative)",id:"ipc-based-ui-bridge-alternative",level:2},{value:"Log File Location",id:"log-file-location",level:2},{value:"Reading Logs from Rust",id:"reading-logs-from-rust",level:2},{value:"Integration with External Tools",id:"integration-with-external-tools",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Logs Not Being Written",id:"logs-not-being-written",level:3},{value:"Tab Changes Not Captured",id:"tab-changes-not-captured",level:3},{value:"Auto-Registration Not Working",id:"auto-registration-not-working",level:3},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"tauri-desktop-guide",children:"Tauri Desktop Guide"})}),"\n",(0,i.jsx)(n.p,{children:"Complete guide for integrating UI Bridge with Tauri desktop applications, including auto-registration and render logging with file-based storage."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Tauri apps have unique requirements:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"IPC Bridge"}),": Communication between React frontend and Rust backend"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"File Storage"}),": Render logs can be persisted to the filesystem"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Desktop Context"}),": Access to system features and local files"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"npm install ui-bridge\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note: ",(0,i.jsx)(n.code,{children:"ui-bridge-server"})," is typically not needed for Tauri apps since communication happens via Tauri's IPC system rather than HTTP."]}),"\n",(0,i.jsx)(n.h2,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,i.jsx)(n.h3,{id:"1-add-the-provider",children:"1. Add the Provider"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// App.tsx\nimport { UIBridgeProvider, AutoRegisterProvider } from 'ui-bridge';\n\nexport default function App() {\n  return (\n    <UIBridgeProvider\n      features={{\n        renderLog: true,\n        control: true,\n        debug: import.meta.env.DEV,\n      }}\n    >\n      <AutoRegisterProvider enabled={import.meta.env.DEV}>\n        <YourApp />\n      </AutoRegisterProvider>\n    </UIBridgeProvider>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-add-render-logging-with-tauri-storage",children:"2. Add Render Logging with Tauri Storage"}),"\n",(0,i.jsx)(n.p,{children:"Create a custom storage backend that persists to files via Tauri:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// lib/ui-bridge/TauriRenderLogStorage.ts\nimport { invoke } from '@tauri-apps/api/core';\nimport type { RenderLogStorage, RenderLogEntry } from 'ui-bridge';\n\nexport class TauriRenderLogStorage implements RenderLogStorage {\n  private maxEntries: number;\n  private taskRunId?: number;\n\n  constructor(options: { maxEntries?: number; taskRunId?: number } = {}) {\n    this.maxEntries = options.maxEntries ?? 1000;\n    this.taskRunId = options.taskRunId;\n  }\n\n  setTaskRunId(id: number) {\n    this.taskRunId = id;\n  }\n\n  async append(entry: RenderLogEntry): Promise<void> {\n    try {\n      await invoke('append_render_log', {\n        entry: {\n          ...entry,\n          task_run_id: this.taskRunId,\n        },\n      });\n    } catch (error) {\n      console.debug('[TauriRenderLogStorage] Failed to append:', error);\n    }\n  }\n\n  async getEntries(options?: {\n    type?: string;\n    since?: number;\n    until?: number;\n    limit?: number;\n  }): Promise<RenderLogEntry[]> {\n    try {\n      return await invoke('load_render_log', options);\n    } catch (error) {\n      console.debug('[TauriRenderLogStorage] Failed to load:', error);\n      return [];\n    }\n  }\n\n  async clear(): Promise<void> {\n    try {\n      await invoke('clear_render_log');\n    } catch (error) {\n      console.debug('[TauriRenderLogStorage] Failed to clear:', error);\n    }\n  }\n\n  async count(): Promise<number> {\n    const entries = await this.getEntries();\n    return entries.length;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-create-the-render-log-manager-hook",children:"3. Create the Render Log Manager Hook"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// lib/ui-bridge/useRenderLogManager.ts\nimport { useEffect, useRef, useCallback } from 'react';\nimport { RenderLogManager } from 'ui-bridge';\nimport { TauriRenderLogStorage } from './TauriRenderLogStorage';\n\nexport interface UseRenderLogManagerOptions {\n  enabled?: boolean;\n  activeTab?: string;\n  taskRunId?: number;\n  captureOnNavigation?: boolean;\n  captureChanges?: boolean;\n  maxEntries?: number;\n}\n\nexport function useRenderLogManager(options: UseRenderLogManagerOptions = {}) {\n  const {\n    enabled = true,\n    activeTab,\n    taskRunId,\n    captureOnNavigation = true,\n    captureChanges = true,\n    maxEntries = 1000,\n  } = options;\n\n  const isDev = import.meta.env.DEV;\n  const isEnabled = enabled && isDev;\n\n  const storageRef = useRef<TauriRenderLogStorage | null>(null);\n  const managerRef = useRef<RenderLogManager | null>(null);\n  const lastTabRef = useRef<string | undefined>(undefined);\n\n  // Initialize\n  useEffect(() => {\n    if (!isEnabled) return;\n\n    storageRef.current = new TauriRenderLogStorage({ maxEntries, taskRunId });\n    managerRef.current = new RenderLogManager({\n      storage: storageRef.current,\n      captureOnNavigation,\n      captureChanges,\n      maxEntries,\n    });\n\n    managerRef.current.start();\n\n    return () => {\n      managerRef.current?.stop();\n      managerRef.current = null;\n      storageRef.current = null;\n    };\n  }, [isEnabled, captureOnNavigation, captureChanges, maxEntries]);\n\n  // Update task run ID\n  useEffect(() => {\n    if (storageRef.current && taskRunId !== undefined) {\n      storageRef.current.setTaskRunId(taskRunId);\n    }\n  }, [taskRunId]);\n\n  // Capture on tab change\n  useEffect(() => {\n    if (!isEnabled || !managerRef.current) return;\n    if (lastTabRef.current === activeTab) return;\n\n    const previousTab = lastTabRef.current;\n    lastTabRef.current = activeTab;\n\n    if (previousTab === undefined) return;\n\n    setTimeout(() => {\n      managerRef.current?.captureSnapshot({\n        trigger: 'tab_change',\n        previousTab,\n        newTab: activeTab,\n      });\n    }, 100);\n  }, [isEnabled, activeTab]);\n\n  const captureSnapshot = useCallback(async (trigger = 'manual') => {\n    if (!managerRef.current) return;\n    await managerRef.current.captureSnapshot({ trigger, activeTab, taskRunId });\n  }, [activeTab, taskRunId]);\n\n  return { captureSnapshot, isRunning: !!managerRef.current };\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-create-the-render-log-wrapper",children:"4. Create the Render Log Wrapper"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// lib/ui-bridge/RenderLogWrapper.tsx\nimport type { ReactNode } from 'react';\nimport { useRenderLogManager } from './useRenderLogManager';\n\nexport interface RenderLogWrapperProps {\n  children: ReactNode;\n  activeTab: string;\n  taskRunId?: number;\n  enableOnMount?: boolean;\n  enableMutationObserver?: boolean;\n}\n\nexport function RenderLogWrapper({\n  children,\n  activeTab,\n  taskRunId,\n  enableOnMount = true,\n  enableMutationObserver = true,\n}: RenderLogWrapperProps) {\n  useRenderLogManager({\n    enabled: enableOnMount,\n    activeTab,\n    taskRunId,\n    captureOnNavigation: true,\n    captureChanges: enableMutationObserver,\n  });\n\n  return <>{children}</>;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"5-add-rust-commands-backend",children:"5. Add Rust Commands (Backend)"}),"\n",(0,i.jsx)(n.p,{children:"Add these commands to your Tauri backend:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// src-tauri/src/commands/logging.rs\n\nuse serde::{Deserialize, Serialize};\nuse std::fs::{self, OpenOptions};\nuse std::io::{BufRead, BufReader, Write};\nuse std::path::PathBuf;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct RenderLogEntry {\n    pub id: String,\n    #[serde(rename = "type")]\n    pub entry_type: String,\n    pub timestamp: i64,\n    pub data: serde_json::Value,\n    pub metadata: Option<serde_json::Value>,\n    pub task_run_id: Option<i64>,\n}\n\nfn get_render_log_path() -> PathBuf {\n    // Store in .dev-logs directory\n    let path = PathBuf::from(".dev-logs/render.log");\n    if let Some(parent) = path.parent() {\n        fs::create_dir_all(parent).ok();\n    }\n    path\n}\n\n#[tauri::command]\npub async fn append_render_log(entry: RenderLogEntry) -> Result<(), String> {\n    let path = get_render_log_path();\n    let mut file = OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(&path)\n        .map_err(|e| e.to_string())?;\n\n    let json = serde_json::to_string(&entry).map_err(|e| e.to_string())?;\n    writeln!(file, "{}", json).map_err(|e| e.to_string())?;\n\n    Ok(())\n}\n\n#[tauri::command]\npub async fn load_render_log(\n    limit: Option<usize>,\n) -> Result<Vec<RenderLogEntry>, String> {\n    let path = get_render_log_path();\n\n    if !path.exists() {\n        return Ok(vec![]);\n    }\n\n    let file = fs::File::open(&path).map_err(|e| e.to_string())?;\n    let reader = BufReader::new(file);\n\n    let entries: Vec<RenderLogEntry> = reader\n        .lines()\n        .filter_map(|line| line.ok())\n        .filter_map(|line| serde_json::from_str(&line).ok())\n        .collect();\n\n    match limit {\n        Some(n) => Ok(entries.into_iter().rev().take(n).rev().collect()),\n        None => Ok(entries),\n    }\n}\n\n#[tauri::command]\npub async fn clear_render_log() -> Result<(), String> {\n    let path = get_render_log_path();\n    if path.exists() {\n        fs::remove_file(&path).map_err(|e| e.to_string())?;\n    }\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Register the commands in your Tauri app:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// src-tauri/src/main.rs\nfn main() {\n    tauri::Builder::default()\n        .invoke_handler(tauri::generate_handler![\n            commands::logging::append_render_log,\n            commands::logging::load_render_log,\n            commands::logging::clear_render_log,\n        ])\n        .run(tauri::generate_context!())\n        .expect("error while running tauri application");\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// App.tsx\nimport { useState } from 'react';\nimport { UIBridgeProvider, AutoRegisterProvider } from 'ui-bridge';\nimport { RenderLogWrapper } from './lib/ui-bridge';\n\nexport default function App() {\n  const [activeTab, setActiveTab] = useState('home');\n  const [taskRunId, setTaskRunId] = useState<number | undefined>();\n\n  return (\n    <UIBridgeProvider\n      features={{\n        renderLog: true,\n        control: true,\n        debug: import.meta.env.DEV,\n      }}\n    >\n      {/* Auto-register all interactive elements */}\n      <AutoRegisterProvider\n        enabled={import.meta.env.DEV}\n        idStrategy=\"prefer-existing\"\n        debounceMs={100}\n        excludeSelectors={['[data-no-register]']}\n      >\n        {/* Capture DOM snapshots on tab changes */}\n        <RenderLogWrapper\n          activeTab={activeTab}\n          taskRunId={taskRunId}\n          enableOnMount={true}\n          enableMutationObserver={true}\n        >\n          <div className=\"app\">\n            <Sidebar\n              activeTab={activeTab}\n              onTabChange={setActiveTab}\n            />\n            <MainContent tab={activeTab} />\n          </div>\n        </RenderLogWrapper>\n      </AutoRegisterProvider>\n    </UIBridgeProvider>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"ipc-based-ui-bridge-alternative",children:"IPC-Based UI Bridge (Alternative)"}),"\n",(0,i.jsx)(n.p,{children:"For Tauri apps, you can expose UI Bridge via IPC instead of HTTP:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// hooks/useUIBridgeEventHandler.ts\nimport { useEffect } from 'react';\nimport { listen, emit } from '@tauri-apps/api/event';\nimport { useUIBridge } from 'ui-bridge/react';\n\nexport function UIBridgeEventHandler() {\n  const bridge = useUIBridge();\n\n  useEffect(() => {\n    const unlisten = listen('ui-bridge-request', async (event) => {\n      const { requestId, method, params } = event.payload as any;\n\n      let result;\n      try {\n        switch (method) {\n          case 'get_elements':\n            result = bridge.getElements();\n            break;\n          case 'click':\n            await bridge.executor.click(params.id);\n            result = { success: true };\n            break;\n          case 'get_snapshot':\n            result = await bridge.renderLog?.getLatestSnapshot();\n            break;\n          // ... other methods\n        }\n        emit('ui-bridge-response', { requestId, result });\n      } catch (error) {\n        emit('ui-bridge-response', { requestId, error: String(error) });\n      }\n    });\n\n    return () => { unlisten.then(fn => fn()); };\n  }, [bridge]);\n\n  return null;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"log-file-location",children:"Log File Location"}),"\n",(0,i.jsxs)(n.p,{children:["Render logs are stored in ",(0,i.jsx)(n.code,{children:".dev-logs/render.log"})," (JSONL format):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{"id":"1705123456-abc123","type":"snapshot","timestamp":1705123456789,"data":{...}}\n{"id":"1705123457-def456","type":"snapshot","timestamp":1705123457123,"data":{...}}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"reading-logs-from-rust",children:"Reading Logs from Rust"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Read logs programmatically\nlet entries = load_render_log(Some(10)).await?;\nfor entry in entries {\n    println!("Entry: {} at {}", entry.id, entry.timestamp);\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-external-tools",children:"Integration with External Tools"}),"\n",(0,i.jsx)(n.p,{children:"You can read the render log from external tools:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Python script to read Tauri render logs\nimport json\n\nwith open('.dev-logs/render.log', 'r') as f:\n    for line in f:\n        entry = json.loads(line)\n        print(f\"{entry['timestamp']}: {entry['type']}\")\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Tail the log file\ntail -f .dev-logs/render.log | jq '.'\n"})}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.h3,{id:"logs-not-being-written",children:"Logs Not Being Written"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Verify ",(0,i.jsx)(n.code,{children:".dev-logs/"})," directory exists"]}),"\n",(0,i.jsx)(n.li,{children:"Check Rust command is registered"}),"\n",(0,i.jsx)(n.li,{children:"Verify IPC invoke is working"}),"\n",(0,i.jsx)(n.li,{children:"Check browser console for errors"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"tab-changes-not-captured",children:"Tab Changes Not Captured"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Verify ",(0,i.jsx)(n.code,{children:"activeTab"})," prop is changing"]}),"\n",(0,i.jsxs)(n.li,{children:["Check ",(0,i.jsx)(n.code,{children:"RenderLogWrapper"})," receives the prop"]}),"\n",(0,i.jsx)(n.li,{children:"Verify tab change triggers component update"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"auto-registration-not-working",children:"Auto-Registration Not Working"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Verify ",(0,i.jsx)(n.code,{children:"AutoRegisterProvider"})," is enabled"]}),"\n",(0,i.jsxs)(n.li,{children:["Check ",(0,i.jsx)(n.code,{children:"import.meta.env.DEV"})," is true"]}),"\n",(0,i.jsxs)(n.li,{children:["Add ",(0,i.jsx)(n.code,{children:"data-testid"})," to elements for explicit registration"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../react/auto-registration",children:"Auto-Registration"})," - Configuration options"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../react/render-logging",children:"Render Logging"})," - Capture configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"../server/standalone",children:"IPC Integration"})," - Custom server setup"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);
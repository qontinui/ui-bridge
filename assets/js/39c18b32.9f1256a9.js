"use strict";(globalThis.webpackChunkui_bridge_docs=globalThis.webpackChunkui_bridge_docs||[]).push([[7318],{4810(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>r});const s=JSON.parse('{"id":"advanced/websocket-communication","title":"WebSocket Communication","description":"UI Bridge supports WebSocket communication for real-time, bidirectional interaction with the UI. This provides lower latency than HTTP polling and enables push-based updates.","source":"@site/docs/advanced/websocket-communication.md","sourceDirName":"advanced","slug":"/advanced/websocket-communication","permalink":"/ui-bridge/docs/advanced/websocket-communication","draft":false,"unlisted":false,"editUrl":"https://github.com/qontinui/ui-bridge/tree/main/docs-site/docs/advanced/websocket-communication.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Accessibility","permalink":"/ui-bridge/docs/observability/accessibility"},"next":{"title":"Recording & Playback","permalink":"/ui-bridge/docs/advanced/recording-playback"}}');var i=t(4848),c=t(8453);const l={},a="WebSocket Communication",o={},r=[{value:"Overview",id:"overview",level:2},{value:"Enabling WebSocket",id:"enabling-websocket",level:2},{value:"Server-Side",id:"server-side",level:3},{value:"Client-Side",id:"client-side",level:3},{value:"Message Protocol",id:"message-protocol",level:2},{value:"Message Format",id:"message-format",level:3},{value:"Request/Response",id:"requestresponse",level:3},{value:"Event Messages",id:"event-messages",level:3},{value:"Client Usage",id:"client-usage",level:2},{value:"Execute Actions",id:"execute-actions",level:3},{value:"Subscribe to Events",id:"subscribe-to-events",level:3},{value:"Stream Updates",id:"stream-updates",level:3},{value:"Connection Management",id:"connection-management",level:2},{value:"Auto-Reconnection",id:"auto-reconnection",level:3},{value:"Connection Status",id:"connection-status",level:3},{value:"Manual Disconnect",id:"manual-disconnect",level:3},{value:"HTTP Fallback",id:"http-fallback",level:2},{value:"Server Events",id:"server-events",level:2},{value:"Push Updates to Clients",id:"push-updates-to-clients",level:3},{value:"Handle Client Messages",id:"handle-client-messages",level:3},{value:"Authentication",id:"authentication",level:2},{value:"Token-Based",id:"token-based",level:3},{value:"Custom Headers",id:"custom-headers",level:3},{value:"Multiplexing",id:"multiplexing",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Client Options",id:"client-options",level:3},{value:"Server Options",id:"server-options",level:3},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"websocket-communication",children:"WebSocket Communication"})}),"\n",(0,i.jsx)(n.p,{children:"UI Bridge supports WebSocket communication for real-time, bidirectional interaction with the UI. This provides lower latency than HTTP polling and enables push-based updates."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"WebSocket communication provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Real-time action execution"}),"\n",(0,i.jsx)(n.li,{children:"Live state updates"}),"\n",(0,i.jsx)(n.li,{children:"Event streaming"}),"\n",(0,i.jsx)(n.li,{children:"Automatic reconnection"}),"\n",(0,i.jsx)(n.li,{children:"HTTP fallback support"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"enabling-websocket",children:"Enabling WebSocket"}),"\n",(0,i.jsx)(n.h3,{id:"server-side",children:"Server-Side"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { createUIBridgeServer } from '@anthropic/ui-bridge-server';\n\nconst server = createUIBridgeServer({\n  transport: 'websocket',\n  port: 9876,\n  path: '/ws',\n});\n\nserver.start();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"client-side",children:"Client-Side"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { UIBridgeClient } from '@anthropic/ui-bridge';\n\nconst client = new UIBridgeClient({\n  transport: 'websocket',\n  url: 'ws://localhost:9876/ws',\n});\n\nawait client.connect();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"message-protocol",children:"Message Protocol"}),"\n",(0,i.jsx)(n.h3,{id:"message-format",children:"Message Format"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface Message {\n  type: string;\n  id: string;\n  payload: any;\n  timestamp: number;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"requestresponse",children:"Request/Response"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Request\n{\n  "type": "execute",\n  "id": "msg-123",\n  "payload": {\n    "action": "click",\n    "elementId": "submit-btn"\n  },\n  "timestamp": 1705312200000\n}\n\n// Response\n{\n  "type": "execute.result",\n  "id": "msg-123",\n  "payload": {\n    "success": true,\n    "duration": 150\n  },\n  "timestamp": 1705312200150\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"event-messages",children:"Event Messages"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// State change event\n{\n  "type": "event.stateChange",\n  "id": "evt-456",\n  "payload": {\n    "from": "logged-out",\n    "to": "logged-in"\n  },\n  "timestamp": 1705312200000\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"client-usage",children:"Client Usage"}),"\n",(0,i.jsx)(n.h3,{id:"execute-actions",children:"Execute Actions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const result = await client.execute('submit-btn', 'click');\n"})}),"\n",(0,i.jsx)(n.h3,{id:"subscribe-to-events",children:"Subscribe to Events"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"client.on('stateChange', (event) => {\n  console.log(`State: ${event.from} -> ${event.to}`);\n});\n\nclient.on('elementAdded', (event) => {\n  console.log(`New element: ${event.elementId}`);\n});\n\nclient.on('elementRemoved', (event) => {\n  console.log(`Removed: ${event.elementId}`);\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"stream-updates",children:"Stream Updates"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Subscribe to registry updates\nconst unsubscribe = client.subscribeToRegistry((snapshot) => {\n  console.log(`Elements: ${snapshot.elements.length}`);\n});\n\n// Later: unsubscribe()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"connection-management",children:"Connection Management"}),"\n",(0,i.jsx)(n.h3,{id:"auto-reconnection",children:"Auto-Reconnection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const client = new UIBridgeClient({\n  transport: 'websocket',\n  url: 'ws://localhost:9876/ws',\n  reconnect: {\n    enabled: true,\n    maxAttempts: 10,\n    delay: 1000,\n    backoff: 'exponential',\n  },\n});\n\nclient.on('disconnected', () => {\n  console.log('Connection lost, reconnecting...');\n});\n\nclient.on('reconnected', () => {\n  console.log('Connection restored');\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"connection-status",children:"Connection Status"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"console.log(client.status);\n// 'connecting' | 'connected' | 'disconnected' | 'reconnecting'\n\nclient.on('statusChange', (status) => {\n  console.log(`Connection status: ${status}`);\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"manual-disconnect",children:"Manual Disconnect"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"await client.disconnect();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"http-fallback",children:"HTTP Fallback"}),"\n",(0,i.jsx)(n.p,{children:"When WebSocket is unavailable:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const client = new UIBridgeClient({\n  transport: 'websocket',\n  url: 'ws://localhost:9876/ws',\n  fallback: {\n    enabled: true,\n    transport: 'http',\n    url: 'http://localhost:9876/api',\n    pollInterval: 500,\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"server-events",children:"Server Events"}),"\n",(0,i.jsx)(n.h3,{id:"push-updates-to-clients",children:"Push Updates to Clients"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Send to all clients\nserver.broadcast({\n  type: 'notification',\n  payload: { message: 'Server restarting in 60 seconds' },\n});\n\n// Send to specific client\nserver.send(clientId, {\n  type: 'result',\n  payload: { success: true },\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"handle-client-messages",children:"Handle Client Messages"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"server.on('message', (clientId, message) => {\n  console.log(`Message from ${clientId}:`, message);\n});\n\nserver.on('execute', async (clientId, { elementId, action }) => {\n  const result = await registry.executeAction(elementId, action);\n  server.send(clientId, { type: 'execute.result', payload: result });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsx)(n.h3,{id:"token-based",children:"Token-Based"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const client = new UIBridgeClient({\n  transport: 'websocket',\n  url: 'ws://localhost:9876/ws',\n  auth: {\n    type: 'token',\n    token: 'your-auth-token',\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"custom-headers",children:"Custom Headers"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const client = new UIBridgeClient({\n  transport: 'websocket',\n  url: 'ws://localhost:9876/ws',\n  headers: {\n    'Authorization': 'Bearer token',\n    'X-Client-ID': 'client-123',\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"multiplexing",children:"Multiplexing"}),"\n",(0,i.jsx)(n.p,{children:"Support multiple channels over one connection:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Subscribe to specific channels\nconst registryChannel = client.channel('registry');\nconst eventsChannel = client.channel('events');\n\nregistryChannel.on('update', (data) => {\n  // Handle registry updates\n});\n\neventsChannel.on('action', (data) => {\n  // Handle action events\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"client-options",children:"Client Options"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const client = new UIBridgeClient({\n  transport: 'websocket',\n  url: 'ws://localhost:9876/ws',\n\n  // Connection\n  timeout: 10000,\n  pingInterval: 30000,\n\n  // Reconnection\n  reconnect: {\n    enabled: true,\n    maxAttempts: 10,\n    delay: 1000,\n    backoff: 'exponential',\n  },\n\n  // Fallback\n  fallback: {\n    enabled: true,\n    transport: 'http',\n    url: 'http://localhost:9876/api',\n  },\n\n  // Buffering\n  messageBuffer: {\n    enabled: true,\n    maxSize: 100,\n    flushOnReconnect: true,\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"server-options",children:"Server Options"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const server = createUIBridgeServer({\n  transport: 'websocket',\n  port: 9876,\n  path: '/ws',\n\n  // Connection limits\n  maxConnections: 100,\n  idleTimeout: 60000,\n\n  // Message handling\n  maxMessageSize: 1024 * 1024,  // 1MB\n\n  // Security\n  cors: {\n    origin: '*',\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use WebSocket for Real-Time"})," - Prefer WebSocket when low latency matters"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Enable Fallback"})," - Always have HTTP fallback for compatibility"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Handle Disconnections"})," - Implement reconnection logic"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Buffer Messages"})," - Buffer during disconnection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authenticate Connections"})," - Secure WebSocket endpoints"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitor Connection Health"})," - Track ping/pong for connection status"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>l,x:()=>a});var s=t(6540);const i={},c=s.createContext(i);function l(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);